Apuntes Spring

En el controlador hay que definir en la clase la anotacion @Controller

Por cada metodo podemos definir las siguientes anotaciones

Con esta anotacion seleccionamos el tipo de peticion y el tipo de llamada (GET , POST ... ETC)
@RequestMapping( value = "/index" , method = RequestMethod.GET)

Tmbien hay anotaciones espesificas para el tipo de llamada
@GetMapping( value = "/index")
@PostMapping
@PutMapping
@DeleteMapping
@PathMapping

... etc

Tambien puedes hacer que una llamada se mapee por multiples sitios 
En este caso estamos diciendo que por el metodo get cuando ponga /index , / o /home va adevolver la vista del metodo
@GetMapping({"/index", "/", "home"})

------------------------------------------

para pasar datos a la vista podemos definir en el metodo la clase ModelMap,  la interfaz model o llamar tambien a la interfe z map.

	@GetMapping({"/index", "/", "home"})
	public String index(ModelMap model) {
		
		model.addAttribute("titulo", "Hola Spring Framwork!");
		
		return "index";
	}
	
	
Ejemplo con map:

	@GetMapping({"/index", "/", "home"})
	public String index(Map<String, Object> map) {
		
		map.put("titulo", "Hola Spring Framwork!");
		
		return "index";
	}	

------------------------------------------------------------
Con la clase ModelAndView podemos definir el nombre de la vista a devolver y definir attributos a enviar.


	@GetMapping({"/index", "/", "home"})
	public ModelAndView index(ModelAndView mv) {
		
		mv.addObject("titulo", "Hola Spring con Model And View!");
		
		mv.setViewName("index");
		
		return mv;
	}
	
	
	
	
	
	
-------------------------------------------------------------
	
para definir el tymeleaf en la vista hay que definir el xml name space

<html xmlns:th="http://www.thymeleaf.org">

para llamar al los attributos definidos podemos utilizar el codi de temeleaf en las etiquetas

<title th:text="${titulo}"></title>
<h1 th:text="${titulo}"></h1>



------------------------------------------------------------------------

INJECCION DE DEPENDENCIAS.
	
La anotacion autowired permite injectar clases por injeccion de dependencia siemple que esas clases tengo alguna anotacion como @Component , @Services , @Controller o @Repository.

Se puede injectar tanto por constructor como por metodos setter

Es recomendable injectar siempre mediante una interfaz.

En el caso que haya 2 clases que implementen esta interfaz spring no sabra que clase tiene que injectar asi que lo suyo es a la  hora de poner la anoacion componen.. etc asignar un nombre @Component("servicio").

y a la hora de injectar utilizar la anotacion @Qualifier("servicio") con el nombre que se le ha dado a la clase.

Tambien se puede utilizar la anotacion @Primary a la hora de definir el componenten para indicar que esa clase es la prioritaria a injectar



@PostConstruct se llama despues de crear la clase


por defecto todos los objetos inyectados con spring son de tipo singleton y permanecen activos mientras el servidor este arrancado.
Si queremos que los objetos se creen y se destruyen al tipo de peticion httpp hay que añadir la anotacion @RequestScope

@SessionScope para el nivel de session (Importante los objetos bean tienen que importar la interfaz serializable)

@applicationScope es a nivel de aplicacion

-------------------------------------------------------------------------------------------------------------------------------------------------

JPA -  HIBERNATE

Todas las clases pojo tienen que tener la anotacion de @Entity del paquete javax

La anotacion @Table(name ="clientes") es opcional espara definir el nombre de la tabla si no se pone se llamara como la clase.

Es importante importar la interfaz serializable ya que cuando se trabaja con json o otro tipo de datos se hace mas factible.

para definir un id hay que utilizar la anotacion @Id
con la anotacion @GenerateValue definimos que el id sera autoincrementar.

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	
La anotacion @Column(name ="create_at") es opcional ya que pordefecto pillara el nombre de la variable.

Con la anotacion @Temporal(TemporalType.DATE) definimos que tipo de fecha queremos que se guarde.

	@Column(name ="create_at")
	@Temporal(TemporalType.DATE)
	private Date createAt;
	

Para crear los DAO hay que crear una interfaz donde se defina el comportamiento.

En la clase que implementa la interfaz hay que definir la anotacion @Repository para indicar que es un componente de spring.

El objeto EntityManager es el que se encarga de rea.lizar la acciones crud

Con la anotacion  @PersistenceContext indicamos que spring lo autogenere (Igual que autowired)

	@PersistenceContext
	private EntityManager em;
	
	
La annotacion @Transactional(readOnly = true) del paquete de spring es  para indicar que un metodo es solo de lectura.

---------------------------------------------------------

Configurar la consola de H2 en spring.

en el fichero de properties

spring.h2.console.enable=true

La url para acceder

http://localhost:8080/h2-console

En la connexion de la BBDD tiene que estar 

jdbc:h2:mem:testdb


Tambien se pueden configurar los datos en el properties

spring.datasource.url=jdbc:h2:mem:clientesdb
spring.datasource.username=ismael
spring.datasourcer.password=sa
spring.datasource.driver-class=org.h2.Driver
spring.h2.console.enable=true

-----------------------------------------------------------------

Configurar MYSQL en el fichero properties

spring.datasource.url=jdbc:mysql://localhost/db_springboot?serverTimezone=Europe/Madrid&useSSL=false
spring.datasource.username=root
spring.datasource.password=ismael23
spring.datasource.driver-class=com.mysql.cj.jdbc.Driver
spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect


En la propiedad "spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect" donde pone 57 es la version de mysql en mi caso es la 5.7
	
Añadir tambien las 2 siguientes lineas para debugar y para que se reeseten los datos

spring.jpa.hibernate.ddl-auto=create-drop
logging.level.org.hibernate.SQL=debug
	
	
---------------------------------------------------------

Para exportar a PDF Utilizamos la libreria openPDF

https://github.com/LibrePDF/OpenPDF

  <dependency>
        <groupId>com.github.librepdf</groupId>
        <artifactId>openpdf</artifactId>
        <version>1.3.0</version>
    </dependency>
	
	

Hay que configurar el application.properties	

	
spring.mvc.contentnegotiation.favor-parameter=true
spring.mvc.contentnegotiation.media-types.pdf = application/pdf
	
	

Pagina de documentacion de Itext para trabajar con las tablas:

https://itextpdf.com/en/resources/examples

----------------------------------------------------------------------------------

para exportar a Excel hay que usar el api de poi apache

Hay que importar las dependencias de maven tanto xml o como la standar

		<!-- https://mvnrepository.com/artifact/org.apache.poi/poi -->
		<dependency>
			<groupId>org.apache.poi</groupId>
			<artifactId>poi</artifactId>
			<version>3.17</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml -->
		<dependency>
			<groupId>org.apache.poi</groupId>
			<artifactId>poi-ooxml</artifactId>
			<version>3.17</version>
		</dependency>




En el properties hay que importar el media type
spring.mvc.contentnegotiation.media-types.xlsx = application/vnd.openxmlformats-officedocument.spreadsheetml.sheet



En el siguiente links hay ejemplos de excel

https://poi.apache.org/components/spreadsheet/examples.html

	
-------------------------------------------------------------------------------

para exportar a CSV

Utilizamos la libreria super csv
http://super-csv.github.io/super-csv/downloading.html


Maven:

		<dependency>
			<groupId>net.sf.supercsv</groupId>
			<artifactId>super-csv</artifactId>
			<version>2.4.0</version>
		</dependency>

-----------------------------------------------------------------------------------------

Para exportar a XML

utilizamos la siguiente libreria "Spring oxm"
https://mvnrepository.com/artifact/org.springframework/spring-oxm


Si estamos utilizando un JDK 9 o superior hay que exportar otra libreria ya que el API-JAXB no esta.

Buscamos por JAXB en maven repossitori y tenemos que agregar 2 dependencias.
JAXB API y JAXB Runtime

https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api

https://mvnrepository.com/artifact/org.glassfish.jaxb/jaxb-runtime

------------------------------------------------------------------------------------------------------
JSON WEB TOKEN

https://jwt.io/

El api que se utiliza en java es : maven: io.jsonwebtoken / jjwt / 0.9.0

https://github.com/jwtk/jjwt

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.10.7</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.10.7</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.10.7</version>
    <scope>runtime</scope>
</dependency>
<!-- Uncomment this next dependency if you want to use RSASSA-PSS (PS256, PS384, PS512) algorithms:
<dependency>
    <groupId>org.bouncycastle</groupId>
    <artifactId>bcprov-jdk15on</artifactId>
    <version>1.60</version>
    <scope>runtime</scope>
</dependency>
-->



---------------------------------------------------------------------
Deploys con tomcat embebido .JAR / .WAR

Tiene que estar configurado el JDK en eclipse hay que hacer un maven install para que genere el jar

Despues desde la consola de comandos. vamos a la carpeta del proyecto y ejecutamos con

java -jar .\target\springbootdatajpa-0.0.1-SNAPSHOT.jar

para ejecutar un WAR seria lo mismo.

java -jar .\target\springbootdatajpa-0.0.1-SNAPSHOT.war

--------------------------------------------------------------------------------
Deploy servidor externo Tomcat



Para desplegar en un servidor externo hay que cambiar la dependencia de tomcat para que no este embebido.

Se tiene que añadir esta dependencia.

	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		
En el packing hay que marcarlo como war.

<packaging>war</packaging>

Tambien hay que quitar la dependencia de devtools si la tenemos.

Si el proyecto esta hecho con JSP  hay que euitar la dependencia tomcat.embed.jasper


Con maven clean limpiamos el directorio target.



Para poder desplegar hay que generar una clase que llamaremos  ServletInitializer y tiene que hederar de  ServletInitializer

Hay que sobrescribir el metodo configure para indicar cuasl es la clase inicial de nuestra aplicacion.


import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;

/**
 * Clase para desplegar en un tomcat externo
 * @author ismael
 *
 */

public class ServletInitializer extends SpringBootServletInitializer {

	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
		
		//Hay que pasar la clase principal de spring
		return builder.sources(SpringbootdatajpaApplication.class);
	}
	
	
	
	

}



Hay que ir a la carperta donde este istalado el tomcat
F:\Formaciones plataforma Udemy\Spring Framework 5 Creando webapp de cero a experto (2019)\Servers\apache-tomcat-9.0.22

una vez dentro hay que ir al directorio bin.

dentro de bin estan todo los comandos.

para levantar apache hacemos :  startup



Hay que copiar el fichero .war dentro del directorio webapps de apache tomcat, actuamoticamente se realizara el despliegue


Para acceder a la web solo hay que poner localhost:8080 y el nombre que tenia el fichero war

por ejemlo http://localhost:8080/springboottomcat-0.0.1-SNAPSHOT/



con shutdown se apaga e servidor.

---------------------------------------------------------------------------------------------------------------------
Desplegar servidor externo wildfly (JBOSS)


Los wars se tienen que copiar en la carpeta wildfly-17.0.1.Final\standalone\deployments


Dentro de la carpeta  bin :  wildfly-17.0.1.Final\bin

Estan todos los ficheros para arrancar el servidor, parara el servidor, hacer el despligue y eliminar un despliegue

Con el comando stanalone levantamos el servidor.

Abrimos un nuevo terminal y abrimos la consola de JBOSS

 Con el comando :  jboss-cli.bat -c
 
 Ahora dentro de la consola ejecutamos el comando deploy y la ruta donde esta el war para desplegar
 
 deploy F:\Formaciones plataforma Udemy\Spring Framework 5 Creando webapp de cero a experto (2019)\Workspace\springbootdatajpa_jboss\target\springbootjboss-0.0.1-SNAPSHOT.war



para acceder hay que poner el nombre del war.

http://localhost:8080/springbootjboss-0.0.1-SNAPSHOT/

 
 con el comando undeploy eliminamos el despliehue
 
 undeploy springbootjboss-0.0.1-SNAPSHOT.war
 
 
 para apagar el servidor hacemos un shutdown desde lña consola de comandos de jboss-cli
 
 exit para salir.
 
tambien podemos hacer    jboss-cli.bat --connect command=:shutdown
para parar el servidor
 
---------------------------------------------------------------------------------------------
Desplegar servidor externo Glassfish


Dentro de la carpeta bin estan los archivos para arrancar el server. glassfish5\bin

con  asadmin.bat start-domain  arrancamos el server

para hacer el deploy utilizamos el siguiente comando

asadmin.bat deploy rutadelarchivo


asadmin.bat list-applications : muestra todas las aplicaciones que tenemos desplegadas


asadmin.bat stop-domain ; parar el servidor.


---------------------------------------------------------------------------------------------------------
Desplegando en Heroku

https://dashboard.heroku.com/apps

Creamo una nueva app.


Hay que descargarse el heroku-cli


se tiene que inicializar el repositorio y subir igual que como si fuera un git.

heroku open : arrancamos el proyecto
heroku logs --tail : visualizar los logs


-----------------------------------------------------------------------
Angular Frontend

----
Hay que instalar node.js

https://nodejs.org/es/

Se recomienda instalar siempre la ultima version LTS

Desde el terminal

node -v : ver la version de node instalada

npm -v : ver la version del sistema de paquetes de node


-------
hay que instalar typescript

https://www.typescriptlang.org/

con node instalado usamos el siguiente comando para instalar typescript

npm install -g typescript

tsc -v : ver version de tyscript instalada


-----------------------------

hay que instalar Angular cli

https://cli.angular.io/

npm install -g @angular/cl : instalar agunlar cli

ng version : ver version de angular


para crear un proyecto angular

ng new nombreproyecto : crear un nuevo proyecto

ng serve : arrancar servidor (Hay que estar en la ruta del proyecto)


------------------------------------------------

uno de los editores para angular es atom

https://atom.io/


Lista de Pluguins a instalar en Atom:

- angular2-typescrypt-snippets
- atom-typescript
- atom-boostrap3
- atom-boostrap4
- v-boostrap4
- platformio-ide-terminal
- file-icons
- emmet
- minimap





------------------------------
Directorios y ficheros de angular

e2e: es donde esta todo lo necesario para testear.

node2_module : estan todas las dependencias de angulas

src : contiene todo el codigo fuente de la aplicacion

.editorconfig : contiene toda la configuracion del editor , charset, tipo de tabulacion ..etc

.gitignore : es un archivo de github que nos permite omitir archivos que no queremos que se suban a git

angular.json : es el archivo de configuracion del proyecto

package.json : contiene el nombre de la aplicacion , la version, las dependencias


app.module.ts : es un repositorio donde se registran todos los componentes



comandos
---------------

ng new nombreproyecto: crear u nnuevo proyecto
ng serve : arrancar servidor
ng generate component : crear un componente
ng generate class : crear una clase
ng generate service : crear una clase de servicio




--------------------------------------------------------------------------------
Crear componentees

todos los component se tiene que importar en el app.modul

los componen se definin con la anotacion @component que se importa del code de angular.
La anotacion se tiene que definir en la clase

Ejemplo :

import { Component} from '@angular/core';

@Component({
  selector: 'app-directiva',
  templateUrl: './directiva.component.html',
  styleUrls: ['./directiva.component.css']
})
export class DirectivaComponent {}

--------------------------------

Crear component de manera automatica por consola

Podemos crear un componente con el comando

ng generate component "nombre de componente" 

hay que estar dentro de la raiz del proyecto

por ejemplo : "<clientes-app> ng generate component directiva"

Tambien podemos usar el comando con alias

ng g c directiva : la g es de generate y la c de component



ng g c clientes/form --flat : con esto indicamos que se cre el componente form dentro de clientes y con el --flat indicamos que no se cree el directorio form




----------------------------------------------------------------------------------------
Uso de directivas de Angular

con la directiva *ngFor podemos iterar bucles

Ejemplo de iterar una lista

<div class="card">
  <div class="card-header">
      Listado de Cursos:
  </div>
  <ul class="list-group">
    <li class="list-group-item" *ngFor="let curso of listaCurso">
      {{curso}}
    </li>
  </ul>
</div>


con la directiva *ngIf evaluamos una expresion

Ejemplo de ngIf para ocultar o mostrar la lista

<button type="button" (click)="habilitar = (habilitar == true)? false : true" class="btn btn-primary my-3">{{habilitar==true ? 'Ocultar' : 'Mostrar'}}</button>
<div class="card">
  <div class="card-header">
      Listado de Cursos:
  </div>

  <ul class="list-group" *ngIf="habilitar == true">
    <li class="list-group-item" *ngFor="let curso of listaCurso">
      {{curso}}
    </li>
  </ul>

</div>


Ejemplo 2 definiendo una funciuon en la clase.

  setHabilitar() : void {
    this.habilitar = (this.habilitar == true) ? false : true

  }
  
  <button type="button" (click)="setHabilitar()" class="btn btn-primary my-3">{{habilitar==true ? 'Ocultar' : 'Mostrar'}}</button>
<div class="card">
  <div class="card-header">
      Listado de Cursos:
  </div>

  <ul class="list-group" *ngIf="habilitar == true">
    <li class="list-group-item" *ngFor="let curso of listaCurso">
      {{curso}}
    </li>
  </ul>

</div>


-------------------------------------
Anotaciones

@Injectable : es que es una clase de servicio se puede injectar por dependencias




------------------------------------------------------------------------
app-moduls

declaration : se definen los componentes
providers: se definen las clases de servicio

Para definir rutas hay que importar las clases RouterModule y Routes.
Creamos un array con las rutas

import {RouterModule, Routes} from '@angular/router';

const routes :Routes = [
  {path:'',redirectTo:'/clientes',pathMatch:'full'},
  {path:'directivas',component:DirectivaComponent},
  {path:'clientes',component:ClientesComponent}
]


Una vez definidas las rutas hay que cargarlas en el import del app-modules
  imports: [
    ....
    RouterModule.forRoot(routes)
  ]
  

 para definir las rutas hay que utilizar la siguiente etiqueta en el app.component.html
  <router-outlet></router-outlet>
 
 Luego en el html donde este el menu
 
podemos utilizar estas 2 direcctivas para definir las rutas

routerLink="/directivas" : para definir la url que esta mapeando
routerLinkActive="active" : para que cuando cambie se marque activa

Por ejemplo:

      <li class="nav-item" routerLinkActive="active">
        <a class="nav-link" routerLink="/directivas">Directivas <span class="sr-only">(current)</span></a>
      </li>
      <li class="nav-item" routerLinkActive="active">
        <a class="nav-link" routerLink="/clientes">Clientes <span class="sr-only">(current)</span></a>
      </li>

	  
	  
	  
------------------------------------
Añadir boostrap al proyecto.

Dentro de la carpeta assets creamos las carpetas css y js

dentro de css añadimos el fichero boostrap.min.css

dentro de js añadimos los javascripts

Luego hay que ir al fichero angular.json y configurar las rutas

por ejrmplo

            "styles": [
              "src/styles.css",
              "src/assets/css/bootstrap.min.css"
            ],
            "scripts": [
              "src/assets/js/jquery-3.3.1.slim.min.js",
              "src/assets/js/popper.min.js",
              "src/assets/js/bootstrap.min.js"
            ]
			
importante cada ve<z que se modifica el angular.json hay que hacer un reinicio

Tambien podemos instalar boostrap utilizando el node package manager npm

npm install boostrap@4.0.0-beta.2 jquery popper.js --save


Se instala dento de node_modules, hay que remplazar las rutas del angular.json por las rutas donde estan los ficheros

por ejemplo "../node_modules/jquery/dist/jquery.slim.min.js"
 
  

---------------------------------------------
Conectarse a un api rest desde el frontend para obtener los datos

Hay que importar el modulo HttpClientModule en el app.module

import { HttpClientModule } from '@angular/common/http';

una vez importado lo registramos en el array de imports

  imports: [
    BrowserModule,
    HttpClientModule,
    RouterModule.forRoot(routes)
  ],
  
  
 Ahora en la clase clienre service tenemos que importar el objeto HttpClientModule
 
 import {HttpClient} from '@angular/common/http';
 
 y tenemos que injectarlo en el constructor
 
 constructor(private http : HttpClient) { }
 
 
 para utilizar el objeto htttp tenemos que llamar el objeto y el verbo, post,get,put, deleted
 
 por ejemplo
 
 definimos la url en una variable 
 
 private urlEndpoint : string = 'http://localhost:8080/api/clientes';
 
 y llamamos al objeto http , Hay que indicar que devulve un array de clientes
 
this.http.get<Cliente[]>(this.urlEndpoint);


----------------------------------------------
Modulo para formularios

Hay que importar el FormModule

import  {FormsModule } from '@angular/forms';  

y añadirlo a imports

  imports: [
    BrowserModule,
    HttpClientModule,
    RouterModule.forRoot(routes),
    FormsModule
  ],
  
  

La directiva [(ngModel)]="" lo que haces es un binding, sirve para guardar / enlazar los datos de un formalurio en un objeto o variable definidas

El binding es en ambas direcciones sirve tanto para guardar como mostrar

por ejemplo en la clase foorm.componente.ts creamos el objeto cliente

private cliente : Cliente = new Cliente();
 
y en el formulario con la directiva hacemos que se guarden los datos.
 
<input type="text" class="form-control" [(ngModel)]="cliente.apellido" name="apellido">

  
Con la directiva (ngSubmit) = "create()" hacemos que cuando se envie el formulario llame al metodo create.

 <form (ngSubmit) = "create()">
 
 
  
 Hay que añadir la url de mapeo del form en el array de Routes del app-modules

 {path: 'clientes/form', component: FormComponent} 
 
 
 
 Con la directiva routerLink podemos crear rutas internas a componentes.
 
 [routerLink] = "['/clientes/form']"
 
 Por ejemplo un botton que lleve al formulario
 
 <button class="btn btn-rounded btn-primary" [routerLink] = "['/clientes/form']">Crear Cliente</button>
 
 
 -----------------------------------------------------------
 
 Instarlar swar alert
 
 Si instalan la última versión del SweetAlert2, la v8.10.0 o superior van a obtener un error:

"Cannot invoke an expression whose type lacks a call signature. "

Con la nueva versión, solo hay que llamar al método fire, según la documentación sería:

        // ES6 Modules or TypeScript
        import swal from 'sweetalert2';
        .... 
        swal.fire(  'The Internet?',  'That thing is still around?',  'success');
        ...
Links: https://sweetalert2.github.io/#examples

Además, en la nueva versión NO agrega automáticamente los estilos CSS, hay que hacerlo a mano en el archivo angular.json, por ejemplo agregando los estilos en la propiedad "styles":

                "styles": [
                  "src/styles.css",
                  ...
                  "node_modules/sweetalert2/dist/sweetalert2.min.css",
                ],


Otra alternativa, pueden instalar la versión 7.26.9 que usamos en el curso, anterior a la 8:

npm install --save sweetalert2@7.26.9


 
---------------------------------------------------------
Control de errores

Hay que importar la clase catchError se encuentra en el mismo paquete que map

import { map, catchError } from 'rxjs/operators';

catchError es para capturar el error enviado del backend

Tambienm hay que importar la clase throwError del mismo paquete que observable y of

import {Observable , of, throwError} from  'rxjs';

throwError sirve para devolver el mensaje de error como un observable


Ejemplo de capturar un error

  getCliente(id) : Observable<Cliente>{
    return this.http.get<Cliente>(`${this.urlEndpoint}/${id}`).pipe(
      catchError(e => {
        this.router.navigate(['/clientes']);
        console.error(e.error.mensaje);
        swal('Error al Editar', e.error.mensaje, 'error');
        return  throwError(e);
      })
    )
  }
  
Ejemplo de crear, update y delete


  create(cliente :Cliente) : Observable<Cliente>{


    return this.http.post(this.urlEndpoint,cliente,{headers :this.httpHeaders}).pipe(
      map( (response : any) => response.cliente as Cliente),
        catchError( e => {
          console.error(e.error.mensaje)
          swal(e.error.mensaje, e.error.error, 'error');
          return  throwError(e);
        })
    );

  }

  update(cliente : Cliente) : Observable<Cliente>{

    return this.http.put<Cliente>(`${this.urlEndpoint}/${cliente.id}`,cliente,{headers: this.httpHeaders}).pipe(
      catchError( e => {
        console.error(e.error.mensaje)
          swal(e.error.mensaje, e.error.error, 'error');
        return  throwError(e);
      })
    );
  }



    delete(id : number) : Observable<Cliente>{

      return this.http.delete<Cliente>(`${this.urlEndpoint}/${id}`, {headers: this.httpHeaders}).pipe(
        catchError( e => {
          console.error(e.error.mensaje)
            swal(e.error.mensaje, e.error.error, 'error');
          return  throwError(e);
        })
      );
   }  
  
 
  



  
  







---------------------------------------------------------------------------------------------
API REST CON Spring Framwork


Configurando el JDBC de mysql en el application properties.

spring.datasource.url=jdbc:mysql://localhost/db_springboot_backend?serverTimezone=Europe/Madrid&useSSL=false
spring.datasource.username=root
spring.datasource.password=ismael23
spring.datasource.driver-class=com.mysql.cj.jdbc.Driver
spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect


en la propiedad "spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect" donde pone 57 es la version de mysql en mi caso es la 5.7

Añadir tambien las 2 siguientes lineas para debugar y para que se reeseten los datos

spring.jpa.hibernate.ddl-auto=create-drop
logging.level.org.hibernate.SQL=debug


---------------------------------
Creando la Clase clientes

una buena practica es implementar la interfaz Serializable

@Entity : es para indicar que esta clase es una entidad de JPA se importa del paque Javax.persistence.Entity

Si la clase se llama igual que la tabla de base de datos no hace falta poner la anotacion table

@Table : para indicar el nombre de la tabla de la BBDD
@Table(name="clientes")

En los atributos tambien podemos añadir anotaciones para indicar que son ampos de la BBDD

@Id : para indicar que es la clave primaria
@GeneratedValue = para indicar que se genere automaticamente el id

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	

@Column = para indicar que un atributto es una columna de la tabla solo se usa si el atributo se llama diferente a la columna

	@Column(name= "nombre_usuario")
	private String nombre;


@Temporal = se utiliza para las fechas para indicar con que tipo de datos queremos trabajar,fechas,tiempo o fechas y tiempo

	@Column(name = "create_at")
	@Temporal(TemporalType.DATE)
	private Date createAt;
	
	
	
@PrePresist : para inicializar algun dato antes de que se guarde en la Base de datos
	@PostMapping("/clientes")
	public Cliente create(@RequestBody Cliente cliente) {
		
		
		
		return clienteService.save(cliente);
		
	}
	
	
	
@ResponseStatus: para que devuelve un codigo al hacerse la peticion
por ejemplo cuando se crear un objeto

	@PostMapping("/clientes")
	@ResponseStatus(HttpStatus.CREATED)
	public Cliente create(@RequestBody Cliente cliente) {
		
		
		
		return clienteService.save(cliente);
		
	}
	
	
	
	
	
	
	
	
	
	
--------------------------------------
Creando las clases de acceso a datos ( DAO o Repository) y la clase Services

La APP JPA ya incluye todo lo necesario para hacer un CRUD

Solo hay que crear una interface y extender de la interface CrudRepository

La interfaz CrudRepository es un tipo generico hay que indicar el dato y el identificar

Por ejemplo Clientes y Long , Long es el id de clientes

IClienteDao extends CrudRepository<Cliente, Long> 


En la documentacion podemos encontrar mas informacion

https://docs.spring.io/spring-data/jpa/docs/2.1.10.RELEASE/reference/html/#repositories.core-concepts


Si generamos metodos propopios en la clase dao hay que utilizar la anotacion Transactional

Se tiene que importar de 
import org.springframework.transaction.annotation.Transactional;

Para consultas
@Transactional(readOnly = true)






------------------------------------------------------------------
Controlador

Como es un api rest hay que anotar la clase con @RestController

Tambien hay que definir la url de mapeo de la clase

@RequestMapping("/api")


@PathVariable : para indicar que vamos a recibir algo en el path

Ejemplo de busqueda de1 cliente por id
	@GetMapping("/clientes/{id}")
	public Cliente show(@PathVariable Long id) {
		
		return clienteService.findById(id);
		
	}
	
	

@RequestBody : para indicar que vamos a recibir un objeto json

	@PostMapping("/clientes")
	public Cliente create(@RequestBody Cliente cliente) {
		
		return clienteService.save(cliente);
		
	}	






--------------------------------------------
Auto Cargar datos de Prueba

En la ruta de resources creamos un archivo con el nombre import.sql

El nombre es importante ya que Spring boot a travez de JPA lo reconoce automaticamente



----------------------------------------------------
CORS

Cors significa intercambio de Recursos de origin Cruzado perimite a los navegadores
modernos enviar y recibir datos restringidos entre diferentes dominios

Primero Hay que configurar cors en el backend

hay que anotar la clase controller con @CrossOrigin

y añadir la url que queremos permitir por ejempñlo en angular http://localhost:4200

Con esta anotacion tambien podemos definir que tipo de peticiones permitimos , GET,POST,PUT..ETC y tambien el tipo de Headers

@CrossOrigin(origins = {"http://localhost:4200"})


--------------------------------------------------------------------

Controlar errores al hacer peticiones.

Con la clase ResponseEntity podemos enviar el objeto ya sea un mensaje y un estado de Http con la clase HttpStatus.

Ejemplo del metodo motrar todo.


	@GetMapping("/clientes/{id}")
	public ResponseEntity<?> show(@PathVariable Long id) {

		
		Cliente cliente = null;
		Map<String, Object> response = new HashMap<>();
		
		try {
			cliente =  clienteService.findById(id);
			
		} catch(DataAccessException e) {
			
			response.put("mensaje", "Error Al Realizar la consulta en la base de datos");
			response.put("error", e.getMessage().concat(": ").concat(e.getMostSpecificCause().getMessage()));
			return new ResponseEntity<Map<String,Object>>(response,HttpStatus.INTERNAL_SERVER_ERROR);
			
		}

		if(cliente == null) {
			response.put("mensaje", "El cliente ID:".concat(id.toString()).concat("No existe en la Base de Datos"));
			
			return new ResponseEntity<Map<String,Object>>(response,HttpStatus.NOT_FOUND);
		
		}

		return new ResponseEntity<Cliente>(cliente,HttpStatus.OK);
				
	}


Ejemplo de crear cliente


	@PostMapping("/clientes")
	public ResponseEntity<?> create(@RequestBody Cliente cliente) {

		Cliente clienteNew = null;
		Map<String, Object> response = new HashMap<>();
		
		try {
			clienteNew = clienteService.save(cliente);
			
		}catch(DataAccessException e){
			
			response.put("mensaje", "Error Al Realizar el Insert en la base de datos");
			response.put("error", e.getMessage().concat(" : ").concat(e.getMostSpecificCause().getMessage()));
			return new ResponseEntity<Map<String,Object>>(response,HttpStatus.INTERNAL_SERVER_ERROR);
		}
		
		response.put("mensaje","El Cliente ha sido creado con exito!");
		response.put("cliente",clienteNew);
		
		
		return new ResponseEntity<Map<String,Object>>(response ,HttpStatus.CREATED);

	}

	
Ejemplo del metodo update

	@PutMapping("/clientes/{id}")
	public ResponseEntity<?> update(@RequestBody Cliente cliente, @PathVariable Long id) {

		Cliente clienteActual = clienteService.findById(id);
		Cliente clienteUpdate = null;

		Map<String, Object> response = new HashMap<>();

		if (clienteActual == null) {
			response.put("mensaje", "Error: no se pudo editar. El cliente ID : ".concat(id.toString())
					.concat(" No existe en la Base de Datos"));

			return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND);

		}

		try {

			clienteActual.setApellido(cliente.getApellido());
			clienteActual.setNombre(cliente.getNombre());
			clienteActual.setEmail(cliente.getEmail());

			clienteUpdate = clienteService.save(clienteActual);

		} catch (DataAccessException e) {

			response.put("mensaje", "Error Al Realizar al Actualizar en la base de datos");
			response.put("error", e.getMessage().concat(" : ").concat(e.getMostSpecificCause().getMessage()));
			return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR);
		}

		response.put("mensaje", "El Cliente ha sido creado con exito!");
		response.put("cliente", clienteUpdate);

		return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED);

	}
	
	
Ejemplo de eliminar

	@DeleteMapping("/clientes/{id}")
	public ResponseEntity<?> delete(@PathVariable Long id) {

		Map<String, Object> response = new HashMap<>();

		try {
			clienteService.delete(id);

		} catch (DataAccessException e) {

			response.put("mensaje", "Error  al eliminar el cliente en la base de datos");
			response.put("error", e.getMessage().concat(" : ").concat(e.getMostSpecificCause().getMessage()));
			return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR);
		}

		response.put("mensaje", "El cliente eliminado con exito!");

		return new ResponseEntity<Map<String, Object>>(response, HttpStatus.OK);

	}
	
--------------------------------------------------------
Api validation de Spring framwork

anotaciones para añadir reglas de validacion en la clase entity

las anotaciones se importan de javax.validation.constraints para spring boot 2

@NotEmpty
@Size(min = 4, max= 12)
@NotEmpty
@Email

ejemplos :

	@NotEmpty
	@Size(min = 4, max= 12)
	@Column(nullable = false)
	private String nombre;
	
	@NotEmpty
	private String apellido;
	
	@NotEmpty
	@Email
	@Column(nullable = false,unique = true)
	private String email;



El controlador hace estas validaciones a travez de un interceptor

para eso hay que utilizar la anotacion @Valid y luego injectar el objeto que tiene todos los mensajes de error

El objeto es BindingResult del paquete org.springframework.validation.BindingResult;



Ejemplo de creat y update


	@PostMapping("/clientes")
	public ResponseEntity<?> create(@Valid @RequestBody Cliente cliente, BindingResult result) {

		Cliente clienteNew = null;
		Map<String, Object> response = new HashMap<>();
		
		//Verificamos si hay errores en las validaciones
		if(result.hasErrors()) {
			
			/*
			  Esta forma es anterior al jdk8
			//Creamos una lista para guardar los campos con errores
			List<String> errors = new ArrayList<>();
			
			//Recorremos la lista de errrores para añadirla en la nueva lista
			for(FieldError err : result.getFieldErrors()) {
				
				errors.add("El campo '" + err.getField() +"' " +err.getDefaultMessage());
				
			}
			*/
			
			//Hace lo mismo que lo anterior pero con programacion funcional
			List<String> errors = result.getFieldErrors()
					.stream()
					.map( err -> "El campo '" + err.getField() +"' " +err.getDefaultMessage())
					.collect(Collectors.toList());
			
			
			response.put("errors", errors);
			
			return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD_REQUEST);
		}

		try {
			clienteNew = clienteService.save(cliente);

		} catch (DataAccessException e) {

			response.put("mensaje", "Error Al Realizar el Insert en la base de datos");
			response.put("error", e.getMessage().concat(" : ").concat(e.getMostSpecificCause().getMessage()));
			return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR);
		}

		response.put("mensaje", "El Cliente ha sido creado con exito!");
		response.put("cliente", clienteNew);

		return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED);

	}

	
	
	@PutMapping("/clientes/{id}")
	public ResponseEntity<?> update(@Valid @RequestBody Cliente cliente, @PathVariable Long id,  BindingResult result) {

		Cliente clienteActual = clienteService.findById(id);
		Cliente clienteUpdate = null;

		Map<String, Object> response = new HashMap<>();
		
		
		if(result.hasErrors()) {
			
			List<String> errors = result.getFieldErrors()
					.stream()
					.map( err -> "El campo '" + err.getField() +"' " +err.getDefaultMessage())
					.collect(Collectors.toList());
			
			
			response.put("errors", errors);
			
			return new ResponseEntity<Map<String, Object>>(response, HttpStatus.BAD_REQUEST);
		}



		if (clienteActual == null) {
			response.put("mensaje", "Error: no se pudo editar. El cliente ID : ".concat(id.toString())
					.concat(" No existe en la Base de Datos"));

			return new ResponseEntity<Map<String, Object>>(response, HttpStatus.NOT_FOUND);

		}

		try {

			clienteActual.setApellido(cliente.getApellido());
			clienteActual.setNombre(cliente.getNombre());
			clienteActual.setEmail(cliente.getEmail());
			clienteActual.setCreateAt(cliente.getCreateAt());

			clienteUpdate = clienteService.save(clienteActual);

		} catch (DataAccessException e) {

			response.put("mensaje", "Error Al Realizar al Actualizar en la base de datos");
			response.put("error", e.getMessage().concat(" : ").concat(e.getMostSpecificCause().getMessage()));
			return new ResponseEntity<Map<String, Object>>(response, HttpStatus.INTERNAL_SERVER_ERROR);
		}

		response.put("mensaje", "El Cliente ha sido actualizado con exito!");
		response.put("cliente", clienteUpdate);

		return new ResponseEntity<Map<String, Object>>(response, HttpStatus.CREATED);

	}



-------------------------------------------
Spring web-flux , programacion Reactiva

Tenemos 2 apis :
https://projectreactor.io/	
http://reactivex.io/

Vamos a utilizar la reactor Api

https://projectreactor.io/docs/core/release/reference/#getting

    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-core</artifactId> 
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId> 
        <scope>test</scope>
    </dependency>
	
	
Para que una aplicacion de Springboot sea de consola hay qye implementar la interfaz CommandLineRunner en la clase inicial de la app





-------------------------------
Instalacion de MongoDB

https://www.mongodb.com/

docomuentacion de mongo
https://docs.mongodb.com/manual/tutorial/getting-started/

Hay que descargar la version comunity que es gratuita

Hay quer agregar la ruta donde estan los ejecutables al path

C:\Program Files\MongoDB\Server\4.2\bin

para comprobrar que esta bien intalado abrimos un cmd y utilizamos el comando.

mongo -version

mongo  : conectarse a la base de datos

db : muestra las base de datos

use nombrebasedatos : para seleccionar una base de datos



ejemplo de insert :

db.inventory.insertMany([
   // MongoDB adds the _id field with an ObjectId if _id is not present
   { item: "journal", qty: 25, status: "A",
       size: { h: 14, w: 21, uom: "cm" }, tags: [ "blank", "red" ] },
   { item: "notebook", qty: 50, status: "A",
       size: { h: 8.5, w: 11, uom: "in" }, tags: [ "red", "blank" ] },
   { item: "paper", qty: 100, status: "D",
       size: { h: 8.5, w: 11, uom: "in" }, tags: [ "red", "blank", "plain" ] },
   { item: "planner", qty: 75, status: "D",
       size: { h: 22.85, w: 30, uom: "cm" }, tags: [ "blank", "red" ] },
   { item: "postcard", qty: 45, status: "A",
       size: { h: 10, w: 15.25, uom: "cm" }, tags: [ "blue" ] }
]);



Ejemplo de busquedas

db.inventory.find()

db.inventory.find( { status: "D" } )

db.inventory.find( { size: { h: 14, w: 21, uom: "cm" } } )


--------------------------
Herramienta grafica para trabajar con mongo ROBO 3T

https://robomongo.org/


----------------------------------------------------------------------
A diferencia de JPA que utilizamos la anotacion @Entity

cuando trabajamos con base de datos no Relacionales tenemos que utilizar

@Document

del paquete org.springframework.data.mongodb.core.mapping.Document


Igual que en jpa podemos indicar el nombre de la tabla aqui se puede indicar el nombre de la coleccion

@Document(collection = "productos")


@Id para indicar que es un id org.springframework.data.annotation.Id; tiene que ser de tipo String



Los objetos se transforman en BSON (Binary Json) que es como trabaja mongodb




En la cacapa dao la interfaz tiene que implementar ReactiveMongoRepository del paquete org.springframework.data.mongodb.repository.ReactiveMongoRepository;

public interface IProductoDao extends ReactiveMongoRepository<Producto, String> {}

--------------------------------------------------------------------
Configurar la BBDD en el application.properties

En caso de no existir la bbdd la crea , mongodb utiliza el puert 27017 por defecto.

spring.data.mongodb.uri= mongodb://localhost:27017/spring_boot_flux



--------------
Configurar el chunk(cache) en el application.properties

Se aplica a todas las vistas.

spring.thymeleaf.reactive.max-chunk-size=1024



Si solo queremos que esta configuracion se aplique algunas vistas usamos la siguiente propiedad

spring.thymeleaf.reactive.chunked-mode-view-names=listar-chunked



-----------------------------------------------------------------------------------------------



<!DOCTYPE html>
<html xmlns:th="http://www.thymeleafe.org">
<head th:replace="layaout/layaout :: head">
<meta charset="UTF-8" />

</head>
<body>
	<header th:replace="layaout/layaout :: header"></header>

	<div class="container py-4">
	
	</div>
	
	<footer th:replace="layaout/layaout :: footer"> </footer>

</body>
</html>





------------------------------------------------------------------------------------------------------------------------

INSERT INTO users (username, password, enable) VALUES ('ismael','$2a$10$7UhDfYUS7OWkXPfVfsMRM.TXQowdIahrum8.EeoQ/FfCvhywFaVMu',1);
INSERT INTO users (username, password, enable) VALUES ('admin','$2a$10$HXohJTAjTRSBtrycshkAueLCdUrr3j2TaqGfJRPL8HIYKz/v0WxhK',1);

INSERT INTO authorities(user_id,authority) VALUES(1,'ROLE_USER');
INSERT INTO authorities(user_id,authority) VALUES(2,'ROLE_USER');
INSERT INTO authorities(user_id,authority) VALUES(2,'ROLE_ADMIN');



---------------------------------------------------------------------------

data-target="#my-target"
id="my-target"



	
		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
		integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
		crossorigin="anonymous"></script>
	<script
		src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
		integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
		crossorigin="anonymous"></script>
	<script
		src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
		integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
		crossorigin="anonymous"></script>
	


	
$2a$10$7UhDfYUS7OWkXPfVfsMRM.TXQowdIahrum8.EeoQ/FfCvhywFaVMu

$2a$10$HXohJTAjTRSBtrycshkAueLCdUrr3j2TaqGfJRPL8HIYKz/v0WxhK
	
	
	
{
	"username" : "ismael",
	"password" : 12345
}	
	
	
Bearer eyJhbGciOiJIUzUxMiJ9.eyJhdXRob3JpdGllcyI6Ilt7XCJhdXRob3JpdHlcIjpcIlJPTEVfVVNFUlwifV0iLCJzdWIiOiJpc21hZWwiLCJpYXQiOjE1NjUyNjMxMTYsImV4cCI6MTU2NTI3NzUxNn0.u6w6y2X-X3hJ3SNJIAOJQnRR7qL3xtVmrruo-4wTcMq5I2zgoTnSvyP6v4LEA1V2BmA6AUbgogQeErjRrwSQqw
Bearer 