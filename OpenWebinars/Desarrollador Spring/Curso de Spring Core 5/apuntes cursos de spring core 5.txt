Spring es un framework de codigo abierto para las creaciones de aplicaciones java.
Estructura Modular y gran flexibilidad.
Permite desarollar aplicacaciones en diferentes arquitectura
Da soporte a groovy y .
Spring se divide en diferente modulos.
Uno de ellos el es el contenedor de INVERSION DE CONTROL 
para la inyeccion de dependencias. (ioc)

---------------------------
Modulos de Spring:
Sprinf framwork - core -ioc -applicaciones web ... etc
Spring boot - Facilita la configuracion y el uso de spring
Spring data - acceso a datos, JPA,JDBC .. ETC
Spring security - Segurida
Spring cloud - Herramientas para sistemas distribuidos microservicios
Spring HATEOAS - simplifica la contrucion de representaciones REST con el uso de hipertextos
Spring bath - Optimiza el volumen de aplicaciones por lote
Spring for android - simplica el desarollo de aplicaciones de android

-----------------------------------
Spring framwotk se divede en varias capas(Modulos)
Test
Core container : Beans , Core , Context , SpEL
AOP
Aspect
Instrumentation
Messaging
WEB : WebSocket , servlet , web Portlet
Data Acces/Integration : JDBC , ORM , OXM ,JMS , Transaction

-------------------------------------------------------
Uso de JDK 8 y Java EE 7.
Compatibilidad con JDK 9 y Java EE 8.
Versiones mínimas: Servlet 3.1, Bean
Validation 1.1, JPA 2.1.
Compatibilidad para Servlet 4.0, Bean
Validation 2.0, JPA 2.2, JSON Binding API 1.0
Compatibilidad para: Tomcat 8.5+, Jetty 9.4+, WildFly 10+
Modulo para web reactiva: WebFlux
Programación funcional con Kotlin
---------------------------------------------------------------

Dependencia para trabajar con el core de IOC

<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.8.RELEASE</version>
</dependency>


-----------------------------------------------------------
Estructura de una aplicacion empresarial y patrones de diseño

APLICACION EMPRESARIAL:
Gran aplicación comercial
Compleja, escalable, distribuida, crítica
Despliegue en redes corporativas o internet
Centrada en los datos.
Intuitiva, de uso fácil.
Requisitos de seguridad y mantenibilidad.

BLOQUES
Personas : Usuarios , Desarolladores .. ets
Datos : Toma de decisiones , datos
Processos : Todas las actividades que se llevan acabo dentro de la empresa ( Proceso de datos e  informacion)
Redes : Canales que vamos a utilizar para desplegar la aplicacion
Tecnologias : Hace referencia al Hardware y al Software


CAPAS:
Interfaz de usuaios : Frontend
Aplicacion : Backend
Datos : Relacional o no relacional
Infraestrucrura de la plataforma
Infraestructura del Hardware : Servidores, tipo de conectivida , plataforma, SO , version de Java


ESTRUCRURA :
Capa de datos : Repositorios
Applicacion : Entidades, Servicios y Controllers
Interfaz de Usuarios : Plantillas


PATRONES :
Inversión de control
Inyección de dependencias
View Helper
Modelo-Vista-Controlador
Data Access Object
Front-Controller


Ámbitos de
un bean:
Inyección de dependencias
Singleton: restringe la creación de objetos de un tipo a uno solo
Prototype: permite la creación de nuevos objetos duplicándolos.

Spring AOP
(Programación
orientada a
aspectos):
Proxy: proporciona un sustituto o representante de un objeto, para controlar el acceso a este


Spring Web MVC :
Modelo-Vista-Controlador: separa la lógica y los datos de la interfaz y el control de peticiones.
Front Controller: un solo controlador maneja todas las peticiones.

Spring IoC Container:
Factory: centralización de la construcción de objetos.


----------------------------------------------
Inversion de control e Inversion de dependencias.

Inversion de Control (IoC) : El objetivo es desacoplar objeto
Que 2 objetos puedan colaborar entre si pero que no interfieran entre ellos.
"Deja que sea otro el que controle el flujo"


Inversion de dependencias : Es una forma de inversion de control.


-------------------------------------------------------
IoC Container


Spring nos permite configurar los metadatos a través de varias formas:
XML
Anotaciones
Código Java (conocido como Java-Config).

Paquetes
org.springframework.beans
org.springframework.context

Los elementos más básicos
BeanFactory: lo elemental para poder manejar cualquier bean objeto.
ApplicationContext: superset del anterior. Añade AOP, manejo de recursos, internacionalización,
contextos específicos, ...


ClassPathXMLApplicationContext : Carga los contenedores desde un cml
FileSystemXMLApplicationContext : Carga el contenedor desde un fichero



Bean: Se trata de un objeto cualquiera gestionado por el IoC



org.springframework.context.ApplicationContext


Responsable de crear instancias, configurar y
ensamblar ls beans.
Se consigue a través de los metadatos
XML
Anotaciones
Java


Dependencia de Spring context :

spring-context-5.0.8.RELEASE.jar
spring-aop-5.0.8.RELEASE.jar
spring-beans-5.0.8.RELEASE.jar
spring-core-5.0.8.RELEASE.jar
spring-jcl-5.0.8.RELEASE.jar
spring-expression-5.0.8.RELEASE.jar

--------------------------------------------------------------------------------
Beans

Objetos manejados por el contenedor ioc
Se crean con los metadatos que nosotros
proporcionamos (por ejemplo, xml).
Debemos darle un id único dentro del
contenedor.
También debemos indicar la clase sobre la
que definimos el bean.

appContext.getBean(id)
Nos obliga a hacer un casting

appContext.getBean(id, class)
Dos argumentos

appContext.getBean(class)
Excepción si repetido

----------------------------------------------------------------------------------
Inner beans (beans anidados)
En ocasiones, podemos crear beans anidados (o internos) a otros beans, en lugar de referenciarlos. ¿Cuál sería la ventaja de un inner bean frente a otro referenciado ?. La respuesta no es difícil: el bean anidados no será accesible desde fuera el bean externo, mientras que el referenciado puede ser accedido por otros beans.

<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
En este ejemplo, el bean de tipo Person solo podría ser accedido por el bean outer.

Colecciones
Spring nos ofrece la posibilidad de inyectar valores dentro de una colección. Los tipos soportados son <list> (java.util.List), <set> (java.util.Set), <map> (java.util.Map), <props> (java.util.Properties).

<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key ="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>


--------------------------------------------------------------------------------------------------
 Inner beans (beans anidados)
Definimos un bean dentro de otro.
Similar a las referencias.
Ámbito más restrictivo.

 Colecciones
Posibilidad de inyectar valores de una
colección
<list>, <set>, <map>, <props>
----------------------------------------------------------------------------------

Spring permite la inyección automática
entre beans que se necesitan.
 Busca candidatos dentro del contexto.
 
Ventajas
Reduce la configuración necesaria
Útil durante el desarrollo. Permite
requerir objetos sin configurarlo
explícitamente.


Autowired
no: sin autocableado
byName: en función del nombre de la propiedad requerida.

byType: en función del tipo de la propiedad requerida. Si hay más de un bean de este
tipo, se produce excepción.

constructor: análogo a byType, pero para
argumentos del constructor.



Es útil si se usa siempre en un proyecto.
En otro caso, puede ser confuso.
No se pueden autoinyectar tipos primitivos o String.
Menos exacto que la inyección explícita
Posible ambigüedad en inyección byType.

No usar el autocableado :(
Manejar el autocableado a través de
anotaciones (lo estudiaremos más
adelante).

Utilizar autowired-candidate=false en
los beans más conflictivos.
Utilizar primary=true en las opciones
principales.



AUTOWIRED-CANDIDATE
Nos permite excluir a un bean de ser
autoinyectado.
Se sigue permitiendo que se pueda
inyectar de forma explícita.


PRIMARY
Nos permite indicar que un bean de un
tipo tendrá preferencia sobre los demás
del mismo tipo.


-----------------------------------------------------------------------
ÁMBITOS DE UN BEAN: SINGLETON Y PROTOTYPE


Cuando definimos un bean (por ejemplo,
en XML) creamos una receta.
Esta nos permite crear instancias reales de
la clase sobre la que definimos el bean.
 A partir de esa receta, es posible crear
muchas instancias.
Podemos configurar el ámbito de un bean
a nivel de configuración (sin tener que
hacerlo al viejo estilo).


SINGLETON
Solo crea una instancia y esta es inyectada para cada bean
Solamente se crea una instancia
compartida de esa clase.
Toda las referencias que obtengamos a
ese bean serán el mismo objeto en
memoria.
Es el ámbito por defecto.

PROTOTYPE 
Se crea una nueva instancia cada vez que el bean es referenciado.
Se crea una instancia cada vez que se le
requiere.
Estas instancias se crean en tiempo de
ejecución.


----------------------------------------------------------------------------------
AMBITO WEB

Solo disponibles con un contexto web (por
ejemplo, XmlWebApplicationContext).
En caso de usar otros no web (por ejemplo
ClassPathXmlApplicationContext)
producirá excepción.
Ámbitos
Request, Session, Application,WebSocket.

AMBITO REQUEST
Se creará un objeto por cada petición
HTTP.
 Cuando la petición termina de procesarse,
se descarta el objeto.

<bean id="loginAction"
 class="com.foo.LoginAction"
 scope="request"/>

 
AMBITO SESSION

Se creará un objeto por cada sesión HTTP
que se cree.
Cuando la sesión se destruye, se descarta
el objeto.

<bean id="userPreferences"
 class="com.foo.UserPreferences"
scope="session"/>

AMBITO APPLICATION

Se creará un objeto por cada
ServletContext.
En la práctica, se trata de un objeto por
cada instancia de la aplicación.

<bean id="appPreferences"
 class="com.foo.AppPreferences"
scope="application"/>

--------------------------------------------------------------------------
CICLO DE VIDA DE UN BEAN

Podemos interactuar mediante callbacks
Después de que se instancie/Antes de que
se destruya.
Interfaces InitializingBean y
DisposableBean.
También a través de XML.


INTERFACES InitializingBean Y DisposableBean.

El bean debe implementar los interfaces.
Desventaja: configuración e implementación van unidos.
Ventaja: la interfaz es un contrato; nos da la firma del método a implementar


public class PersonaDAOImplMemory implements
PersonaDAO, InitializingBean, DisposableBean {
@Override
public void afterPropertiesSet() throws Exception {
insert(new Persona("Luismi", 35));
insert(new Persona("Ana", 32));
insert(new Persona("Pepe", 34));
insert(new Persona("Julia", 39));
}
@Override
public void destroy() throws Exception {
System.out
 .println("Limpiando los datos de la lista");
personas.clear();
}
}


CONFIGURACIÓN VÍA XML
Propiedades init-method y
destroy-method
El valor de la propiedad es un String.
Debe ser el nombre de un método del bean.
void
Sin parámetros
Throws Exception.
Ventaja: bajo acoplamiento

<beans xmlns="http://www.springframework.org/schema/beans"...>
 <bean id="personaDao"
 class="com.openwebinars.lifecycle.PersonaDAOImplMemory"
 init-method="init" destroy-method="destroy" />
</beans>

public class PersonaDAOImplMemory implements PersonaDAO {
 public void init() throws Exception {  }
 public void destroy() throws Exception {  }
}


Propiedades default-init-method y
default-destroy-method
Propiedad de <beans>
Permite definir un nombre de método de
inicialización/destrucción para todos los
beans de un contexto.

<beans xmlns="http://www.springframework.org/schema/beans"...
 default-init-method="init" default-destroy-method="destroy">
 <bean id="personaDao"
 class="com.openwebinars.lifecycle.PersonaDAOImplMemory"/>
</beans>


-------------------------------------------------------------------------------------------
ANOTACIONES

No configuramos los beans con XML.
La configuración está más cerca del código.
Más cerca significa más acoplada.
Desde Spring 2.5
Necesitamos configuración XML mínima (o JavaConfig)

Spring permite extender el contenedor de
IoC.
BeanPostProcessor es un interfaz que nos permite gestionar:
Instanciación
Configuración
Inyección de dependencias
Podemos definir cuantos procesadores necesitemos.


Spring define algunos BeanPostProcessor
útiles:
 AutowiredAnnotationBeanPostProcessor.
 RequiredAnnotationBeanPostProcessor.
 CommonAnnotationBeanPostProcessor.
 PersistenceAnnotationBeanPostProcessor.
 
 
 
La anotación <context:annotation-config />
nos permite registrar los BeanPostProcessor
necesarios para usar las anotaciones.

<beans xmlns="http://www.springframework.org/schema/beans"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns:context="http://www.springframework.org/schema/context"
 xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-4.3.xsd"
>
<context:annotation-config />
</beans>
 
 
 
 
@REQUIRED

Nos permite indicar que una propiedad
debe ser necesariamente inyectada.
No indica cómo cómo debe realizarse la
inyección
Explícita
Autowired
Si no se satisface, produce una excepción.
Permite evitar NPE
 
-------------------------------------------------------------------------------------------
@AUTOWIRTED 

La especificación JSR 330 de Java define un conjunto de anotaciones estándar para la inyección de dependencias.
En nuestro caso, estamos usando las anotaciones propias de Spring, pero podríamos usar perfectamente las estándar con el mismo comportamiento.

Para usar las dependencias estándar, necesitamos añadir la siguiente dependencia Maven:

<dependency>
    <groupId>javax.inject</groupId>
    <artifactId>javax.inject</artifactId>
    <version>1</version>
</dependency>
En lugar de usar @Autowired, podríamos usar la anotación @Inject:

import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.findMovies(...);
        ...
    }
}
 
 
 
Tiene el mismo efecto que la configuración vía XML.
Busca un bean adecuado y lo inyecta en la dependencia.
Se realiza un autocableado byType
 
 
Método setter 
@Autowired
public void setPeliculaDao(PeliculaDao peliculaDao) {...}

Definición de la propiedad
@Autowired
private PeliculaDao peliculaDao;

Constructor
@Autowired
public PeliculaService(PeliculaDao peliculaDao) {...}
 
 
 
USO DE @AUTOWIRED PARA VARIOS OBJETOS DEL MISMO TIPO

Podemos obtener todos los beans de un
mismo tipo
Array
Colección: List, Set, Map

public class PeliculaDaoImplMemory implements PeliculaDao {
@Autowired
private Set<CatalogoPeliculas> catalogosPeliculas;
}

<bean id="catalogoClasicas"
class="com.openwebinars.annotation.CatalogoPeliculasClasicas" />
<bean id="catalogoActuales"
class="com.openwebinars.annotation.CatalogoPeliculasActuales" />

 
 
@AUTOWIRED NO SATISFECHO
 
Si @Autowired no encuentra ningún bean candidato produce excepción.
Podemos modificar este comportamiento para que deje la dependencia sin
satisfacer, pero sin excepción:
@Autowired(required=false)
@Nullable (Spring 5)
Optional<?> (Java 8)


--------------------------------------------------------------------------------
USO DE PRIMARY Y @QUALIFIER
 

@Autowired no funciona correctamente cuando hay más de un candidato de un
mismo tipo.
Necesitamos un mecanismo que nos permita indicar qué bean es el más
adecuado o el seleccionado.

PROPIEDAD PRIMARY 

A nivel XML Permite indicar un bean primus inter pares
Si hay más de un bean de un tipo, y uno de ellos marcado como primary,
@Autowired inyectará dicho bean.
Si hay más de un bean primary, se lanza excepción.
Valor por defecto primary=false


@QUALIFIER
Nos permite afinar mucho más el autocableado.
Podemos seleccionar que bean específico (de entre varios de un tipo) queremos
inyectar.
Mecanismo extensible.

El mecanismo más sencillo es usar el nombre del bean.

public class PeliculaDaoImplMemory
 implements PeliculaDao {
@Autowired
@Qualifier("catalogoClasicas")
private CatalogoPeliculas catalogoPeliculas;
//...
}


También podemos usar @Qualifier a nivel de argumento de un método.

public class MovieRecommender {
 @Autowired
 public void prepare(
 @Qualifier("main") MovieCatalog movieCatalog,
 CustomerPreferenceDao customerPreferenceDao) {
 this.movieCatalog = movieCatalog;
 this.customerPreferenceDao = customerPreferenceDao;
 }
 // ...
}


Podemos indicar explícitamente en XML un valor de qualifier
<bean class="example.SimpleMovieCatalog">
<qualifier value="main"/>
</bean>

<bean class="example.SimpleMovieCatalog">
<qualifier value="action"/>
</bean>



Podemos crear nuestras propias anotaciones para extender @Qualifier

@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Epoca {
String value();
}

<bean id="catalogoClasicas"
 class="com.openwebinars.annotation.CatalogoPeliculasClasicas">
 <qualifier type="Epoca" value="clasicas" />
</bean>

public class PeliculaDaoImplMemory implements PeliculaDao {
@Autowired
@Epoca("clasicas")
private CatalogoPeliculas catalogoPeliculas;
}

-----------------------------------------------------------------------------------------
USO DE @POSTCONSTRUCT Y @PREDESTROY

? Ya hemos visto cómo manejar el ciclo de
vida vía XML.

<beans xmlns="http://www.springframework.org/schema/beans"...>
 <bean id="personaDao"
 class="com.openwebinars.lifecycle.PersonaDAOImplMemory"
 init-method="init" destroy-method="destroy" />
</beans>

public class PersonaDAOImplMemory implements PersonaDAO {
 public void init() throws Exception {  }
 public void destroy() throws Exception {  }
}

Podemos usar las anotaciones

@PostConstruct y @PreDestroy

<beans xmlns="http://www.springframework.org/schema/beans"...>
 <bean id="personaDao"
 class="com.openwebinars.lifecycle.PersonaDAOImplMemory"/>
</beans>

public class PersonaDAOImplMemory implements PersonaDAO {
 @PostConstruct
 public void init() {  }
 @PreDestroy
 public void destroy() {  }
}

------------------------------------------------------------------------------------------------------
Filtrado en el escaneo automático de componentes

Por defecto, cuando utilizamos el escaneo automático de componentes, 
Spring buscará dentro del paquete base (y sus subpaquetes), 
todas las clases anotadas con algún tipo de estereotipo y las incluirá. 
En el caso de que solo queramos seleccionar algunas, podemos utilizar el filtrado.
 Este filtrado puede ser inclusivo o exclusivo, y lo usual es que indiquemos algún tipo de anotación sobre la que filtrar, 
 o una expresión regular sobre el nombre de las clases:

A continuación tenemos un ejemplo:

<beans>
    <context:component-scan base-package="org.example">
        <context:include-filter type="regex"
                expression=".*Service.*Repository"/>
        <context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
</beans>

Los candidatos estarán anotados con algún estereotipo. El más básico es
@Component.

@Component :Estereotipo básico Los demás son derivados de él.
@Service: orientado a las clases servicio, lógica de negocio, ...
@Repository: clases de acceso a datos (DAO)
@Controller: clases que sirven para gestionar las peticiones recibidas.


-------------------------------------------------------------------------------------------------
JAVACONFIG

Spring soporta la configuración vía código Java.
Nos permite prescindir por completo de XML.
Podemos combinar el uso de JavaConfig con las anotaciones trabajadas en el
bloque anterior.

ANOTACIONES CLAVE

@Configuration
A nivel de clase
Indica que una clase va a definir uno o
más 

@Bean
@Bean.
A nivel de método
Equivalente a <bean  />


@Configuration
public class AppConfig {
@Bean
public Saludator saludator() {
return new Saludator();
}
}


Ahora usamos
AnnotationConfigApplicationContext
Recibe como argumento la/s clase/s que tienen alguna configuración.

public static void main(String[] args) {
 ApplicationContext appContext = new
 AnnotationConfigApplicationContext(AppConfig.class);
 Saludator saludator = appContext.getBean(Saludator.class);
 //
}



Podemos usar el constructor vacío y registrar las clases.

public static void main(String[] args) {
 AnnotationConfigApplicationContext ctx =
 new AnnotationConfigApplicationContext();
 ctx.register(AppConfig.class, OtherConfig.class);
 ctx.register(AdditionalConfig.class);
 ctx.refresh();
 MyService myService = ctx.getBean(MyService.class);
 myService.doStuff();
}


ESCANEO DE COMPONENTES

Idéntico comportamiento que en XML
@ComponentScan(basePackages=...)
También programáticamente

public static void main(String[] args) {
 AnnotationConfigApplicationContext ctx =
 new AnnotationConfigApplicationContext();
 ctx.scan("com.acme");
 ctx.refresh();
 MyService myService = ctx.getBean(MyService.class);
}


----------------------------------------------------------------------------------------------
¿Es mejor definir un @Bean a través de una interfaz o del tipo concreto de una clase?
Hemos podido ver en el vídeo que el tipo de retorno de un método anotado con @Bean puede ser una clase o bien una interfaz (o supertipo).

@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
El uso de una interfaz, en lugar del tipo concreto, limita la visibilidad del bean (en el uso de autocableado) al tipo de interfaz especificado ( TransferService). Si constantemente hace referencia a sus tipos mediante una interfaz de servicio declarada, sus tipos de retorno de los métodos @Bean pueden seguir de forma segura esa decisión de diseño. Sin embargo, para los componentes que implementan varias interfaces o para componentes potencialmente referidos por su tipo de implementación, es más seguro declarar el tipo de retorno más específico posible (al menos tan específico como sea requerido por los puntos de inyección referidos a su bean).

Un ejemplo más completo del uso de @Bean
Es posible que con el ejemplo del vídeo no le veamos toda la utilidad a la configuración JavaConfig con @Bean. Eso se debe a que estamos trabajando con una serie de clases para las cuales tenemos acceso al código fuente. Es más, las hemos codificado todas, y podemos añadirle los estereotipos. Pero, ¿y si no fuera el caso? ¿Y si quisieramos crear una serie de beans a partir de clases implementadas por terceros, a cuyo código fuente no tenemos acceso y que no están estereotipadas? Ahí, el uso de JavaConfig y @Bean cobran más sentido.

A continuación os dejo el código fuente de un ejemplo completo de nuestro curso de Hibernate:

package com.openwebinars.hibernate.hbnpost.config;

import java.util.Properties;
import javax.sql.DataSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableTransactionManagement
public class DatabaseConfig {

    /**
     * Definición del DataSource para la conexión a nuestra base de datos.
     * Las propiedades son establecidas desde el fichero de properties, y
     * asignadas usando el objeto env.
     *
     */
    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(env.getProperty("db.driver"));
        dataSource.setUrl(env.getProperty("db.url"));
        dataSource.setUsername(env.getProperty("db.username"));
        dataSource.setPassword(env.getProperty("db.password"));
        return dataSource;
    }

    /**
     *
     * Declaración del EntityManagerFactory de JPA
     */
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean();

        //Le asignamos el dataSource que acabamos de definir.
        entityManagerFactory.setDataSource(dataSource);

        // Le indicamos la ruta donde tiene que buscar las clases anotadas
        entityManagerFactory.setPackagesToScan(env.getProperty("entitymanager.packagesToScan"));

        // Implementación de JPA a usar: Hibernate
        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        entityManagerFactory.setJpaVendorAdapter(vendorAdapter);

        // Propiedades de Hiberante
        Properties additionalProperties = new Properties();
        additionalProperties.put("hibernate.dialect", env.getProperty("hibernate.dialect"));
        additionalProperties.put("hibernate.show_sql", env.getProperty("hibernate.show_sql"));
        additionalProperties.put("hibernate.hbm2ddl.auto", env.getProperty("hibernate.hbm2ddl.auto"));
        entityManagerFactory.setJpaProperties(additionalProperties);

        return entityManagerFactory;
    }

    /**
     * Inicializa y declara el gestor de transacciones
     */
    @Bean
    public JpaTransactionManager transactionManager() {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory.getObject());
        return transactionManager;
    }

    /**
     *  
     * Este bean es un postprocessor que ayuda a relanzar las excepciones específicas
     * de cada plataforma en aquellas clases anotadas con @Repository
     *
     */
    @Bean
    public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {
        return new PersistenceExceptionTranslationPostProcessor();
    }

    @Autowired
    private Environment env;

    @Autowired
    private DataSource dataSource;

    @Autowired
    private LocalContainerEntityManagerFactoryBean entityManagerFactory;

}

---------------------------------------------------------------------------------------------
USO DE @BEAN

@BEAN
Anotación a nivel de método
Define un bean <bean  />
En clases
 @Configuration: preferible
 @Component (y derivados): lite mode
Atributos: name, init-method,
destroy-mehtod, autowiring
  Con este enfoque, seguramente esto se configure vía anotaciones


DECLARACIÓN DE UN BEAN
Un método anotado @Bean
El tipo de retorno es el tipo del bean
El nombre por defecto es el nombre del método.

@Bean
public TransferServiceImpl transferService() {
 return new TransferServiceImpl();
}

<bean id="transferService"
 class="com.acme.TransferServiceImpl"/>



El tipo de retorno puede ser un interfaz o supertipo de la clase instanciada.

@Bean
public TransferService transferService() {
 return new TransferServiceImpl();
}

Un método @Bean puede recibir cero o más parámetros.
Los objetos son dependencias del bean definido.
El contenedor inyectará las mismas (al estilo de la inyección por constructor)



@Configuration
public class AppConfig {
 @Bean
 public TransferService transferService(
 AccountRepository accountRepository) {
 return new TransferServiceImpl(accountRepository);
 }
}
El contenedor se encargará de inyectar la dependencia de tipo AccountRepository.

Podemos definir su ámbito a través de anotaciones.
Scope(singleton): por defecto
Scope(prototype)
@RequestScope
@SessionScope
@ApplicationScope

----------------------------------------------------------------------------------------------
INYECCIÓN DE VALORES @VALUE

Cómo podemos inyectar valores de tipo primitivo (por ejemplo, String)?
@Value
Uso de ficheros de properties
Variables de entorno
Valores por defecto
En realidad, podemos inyectar valores en otros tipos: wrapper, List, ...

mensaje=Hola a todos desde un fichero de propiedades!

@Component
public class Saludator {
@Value("${mensaje}")
private String mensaje;
public String saludo() {
return mensaje;
}
}


------------------------------------------------------------------------------------------------







